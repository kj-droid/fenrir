import subprocess
import os
import logging
import json


class CustomExploitRunner:
    def __init__(self, output_dir="reports/output"):
        """
        Initialize the CustomExploitRunner.
        :param output_dir: Directory to save execution results.
        """
        self.output_dir = output_dir
        self.logger = logging.getLogger("CustomExploitRunner")
        logging.basicConfig(level=logging.INFO)

        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

    def execute_script(self, script_path, args=None):
        """
        Execute a custom script with optional arguments.
        :param script_path: Path to the script to execute.
        :param args: List of arguments to pass to the script.
        :return: Output and status of the execution.
        """
        self.logger.info(f"Executing script: {script_path} with args: {args}")
        try:
            command = ["python3", script_path]
            if args:
                command.extend(args)

            result = subprocess.run(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            if result.returncode != 0:
                self.logger.error(f"Script execution failed: {result.stderr}")
                return {"status": "failed", "output": result.stderr}

            self.logger.info(f"Script executed successfully: {script_path}")
            return {"status": "success", "output": result.stdout}
        except Exception as e:
            self.logger.error(f"Error executing script: {e}")
            return {"status": "error", "output": str(e)}

    def run_command(self, command):
        """
        Execute a shell command.
        :param command: Command string to execute.
        :return: Output and status of the execution.
        """
        self.logger.info(f"Running command: {command}")
        try:
            result = subprocess.run(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            if result.returncode != 0:
                self.logger.error(f"Command execution failed: {result.stderr}")
                return {"status": "failed", "output": result.stderr}

            self.logger.info("Command executed successfully.")
            return {"status": "success", "output": result.stdout}
        except Exception as e:
            self.logger.error(f"Error executing command: {e}")
            return {"status": "error", "output": str(e)}

    def save_results(self, results, output_file="custom_exploit_results.json"):
        """
        Save execution results to a JSON file.
        :param results: Dictionary containing the execution results.
        :param output_file: Name of the output file.
        """
        file_path = os.path.join(self.output_dir, output_file)
        try:
            with open(file_path, "w") as file:
                json.dump(results, file, indent=4)
            self.logger.info(f"Results saved to {file_path}")
        except Exception as e:
            self.logger.error(f"Error saving results: {e}")


if __name__ == "__main__":
    # Example usage
    runner = CustomExploitRunner()

    # Execute a custom Python script
    script_result = runner.execute_script(
        script_path="exploits/custom_exploit.py",
        args=["--target", "192.168.1.1", "--port", "80"]
    )

    # Print script result
    print("\nScript Result:")
    print(script_result)

    # Save results
    runner.save_results(script_result)

    # Run a shell command
    command_result = runner.run_command("ls -la")
    print("\nCommand Result:")
    print(command_result)

    # Save command results
    runner.save_results(command_result, output_file="command_results.json")
